<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta content="text/html; charset=UTF-8" http-equiv="content-type"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<meta name="robots" content="index, follow">













<title>Double-checked locking问题</title>




<meta name="title" content="Double-checked locking问题">


<meta property="og:type" content="website">
<meta property="og:url" content="https://blog.liangliu.me/double-checked-locking/">

<meta property="og:site_name" content="Liang&#x27;s blog">


<meta property="og:title" content="Double-checked locking问题">



<link rel="canonical" href="https://blog.liangliu.me/double-checked-locking/">




<link rel="alternate" type="application/atom+xml" title="RSS" href="https://blog.liangliu.me/rss.xml"> 




<link rel="stylesheet" type="text/css" href="https://blog.liangliu.me/main.css">



    </head>
    <body>
	<header>
	    
                <a class="title" href="https:&#x2F;&#x2F;blog.liangliu.me">
                    <h1>Liang&#x27;s blog</h1>
                </a>
                <nav>
                    <p>
                    <a href="https:&#x2F;&#x2F;blog.liangliu.me">Home</a>
                    <a href="/about">Me</a>
                    <a href="/rss.xml">Rss</a>
                    </p>
                </nav>
	    
	</header>
	<main>
	    
<h1 class="page-title">Double-checked locking问题</h1>
<p>
    <span>2021-12-08</span>
</p>

<p>今天在处理 Fortify 扫描出来的 report 的时候，有个 issue 觉得挺有必要去研究一下的，写个文章记录一下。
issue 里面报告了一个<code>Double-checked locking</code>的问题，对应的代码如下</p>
<pre data-lang="java" style="background-color:#282828;color:#fdf4c1aa;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#8ec07c;">Class A </span><span>{
</span><span>    </span><span style="color:#fa5c4b;">private final </span><span style="color:#8ec07c;">Map</span><span>&lt;</span><span style="color:#8ec07c;">String</span><span>, </span><span style="color:#8ec07c;">B</span><span>&gt; configMap;
</span><span>
</span><span>    </span><span style="color:#fa5c4b;">public </span><span style="color:#8ec07c;">A </span><span>{
</span><span>        </span><span style="color:#fdf4c1;">this</span><span>.configMap </span><span style="color:#fe8019;">= </span><span style="color:#fa5c4b;">new </span><span style="color:#8ec07c;">HashMap</span><span>();
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#fa5c4b;">public </span><span style="color:#8ec07c;">B </span><span style="color:#fdf4c1;">getB(</span><span style="color:#8ec07c;">String</span><span style="color:#fdf4c1;"> name) </span><span>{
</span><span>        </span><span style="color:#fa5c4b;">if </span><span>(</span><span style="color:#fe8019;">!</span><span>configMap.</span><span style="color:#fdf4c1;">contains(name)</span><span>) {
</span><span>            </span><span style="color:#fa5c4b;">synchronized </span><span>(</span><span style="color:#fdf4c1;">this</span><span>) {
</span><span>                </span><span style="color:#fa5c4b;">if </span><span>(</span><span style="color:#fe8019;">!</span><span>configMap.</span><span style="color:#fdf4c1;">contains(name)</span><span>) {
</span><span>                    configMap.</span><span style="color:#fdf4c1;">put(name, </span><span style="color:#fa5c4b;">new </span><span style="color:#8ec07c;">B</span><span style="color:#fdf4c1;">())</span><span>;
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>        </span><span style="color:#fa5c4b;">return</span><span> configMap.</span><span style="color:#fdf4c1;">get(name)</span><span>;
</span><span>    }
</span><span>}
</span></code></pre>
<p>为了保证在多线程环境下相同的 name，不生成多个 B 的实例，这里使用了 Java 程序员经常会使用的双重检测同步代码块来保证对相同的 name，对应的 B 实例只会初始化一次，并且不用去锁住整个方法。</p>
<p>但是为什么这里 Fortify 会报这个错误呢？</p>
<p>去查了一下 Fortify 官方对这个的说明，简单说就是这是一个错误的用法，并不会达到想要的效果，参考引用的 David Bacon 等人的 <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html">文章</a> 我们来看看</p>
<p>这样的代码在编译器有优化或者多处理器共享内存的情况下，并不能达到期望的结果</p>
<pre data-lang="java" style="background-color:#282828;color:#fdf4c1aa;" class="language-java "><code class="language-java" data-lang="java"><span style="font-style:italic;color:#928374;">// Broken multithreaded version
</span><span style="font-style:italic;color:#928374;">// &quot;Double-Checked Locking&quot; idiom
</span><span style="color:#fa5c4b;">class </span><span style="color:#8ec07c;">Foo </span><span>{
</span><span>    </span><span style="color:#fa5c4b;">private </span><span style="color:#8ec07c;">Helper </span><span>helper </span><span style="color:#fe8019;">= </span><span style="color:#d3869b;">null</span><span>;
</span><span>    </span><span style="color:#fa5c4b;">public </span><span style="color:#8ec07c;">Helper getHelper</span><span>() {
</span><span>        </span><span style="color:#fa5c4b;">if </span><span>(helper </span><span style="color:#fe8019;">== </span><span style="color:#d3869b;">null</span><span>)
</span><span>            </span><span style="color:#fa5c4b;">synchronized</span><span>(</span><span style="color:#fdf4c1;">this</span><span>) {
</span><span>                </span><span style="color:#fa5c4b;">if </span><span>(helper </span><span style="color:#fe8019;">== </span><span style="color:#d3869b;">null</span><span>)
</span><span>                helper </span><span style="color:#fe8019;">= </span><span style="color:#fa5c4b;">new </span><span style="color:#8ec07c;">Helper</span><span>();
</span><span>            }
</span><span>        </span><span style="color:#fa5c4b;">return</span><span> helper;
</span><span>        }
</span><span>    </span><span style="font-style:italic;color:#928374;">// other functions and members...
</span><span>}
</span></code></pre>
<p>第一个原因就是<code>new Helper()</code>这个操作和把这个对象赋值给<code>helper</code>变量这个操作并不会按照顺序执行，很有可能<code>new Helper()</code>会在将<code>helper</code>这个变量指向分配的内存之后，比如线程 A 调用<code>getHelper()</code>方法之后，由于指令重排，导致<code>helper</code>变量已经指向了一块分配出来的内存，这个时候它并不是<code>null</code>，但是<code>new Helper()</code>这个还没有执行，这个时候如果线程 B 也执行了<code>getHelper()</code>方法，会导致 B 拿到一个没完全初始化的<code>helper</code>，可能是个默认值，也有可能指向一个错误的内存地址，导致安全问题或者程序 crash。</p>
<p>如果编译器没有进行指令重排，在多核 CPU 平台上 CPU 或者内存系统也可能进行指令重排，也会导致这个问题。</p>
<p>文中给出了一个例子</p>
<pre data-lang="bash" style="background-color:#282828;color:#fdf4c1aa;" class="language-bash "><code class="language-bash" data-lang="bash"><span>    </span><span style="color:#fdf4c1;">to the following (note that the Symantec JIT using a handle-based object allocation system</span><span>)</span><span style="color:#fabd2f;">.
</span><span>
</span><span>    </span><span style="color:#fdf4c1;">0206106A   mov         eax,0F97E78h
</span><span>    </span><span style="color:#fdf4c1;">0206106F   call        01F6B210                  </span><span style="color:#fe8019;">; </span><span style="color:#fdf4c1;">allocate space for
</span><span>                                                    </span><span style="color:#fe8019;">; </span><span style="color:#fdf4c1;">Singleton, return result in eax
</span><span>    </span><span style="color:#fdf4c1;">02061074   mov         dword ptr </span><span style="color:#fa5c4b;">[</span><span style="color:#fdf4c1;">ebp</span><span style="color:#fa5c4b;">]</span><span style="color:#fdf4c1;">,eax       </span><span style="color:#fe8019;">; </span><span style="color:#fdf4c1;">EBP is </span><span style="color:#fe8019;">&amp;</span><span style="color:#fdf4c1;">singletons[i].reference
</span><span>                                                    </span><span style="color:#fe8019;">; </span><span style="color:#fdf4c1;">store the unconstructed object here.
</span><span>    </span><span style="color:#fdf4c1;">02061077   mov         ecx,dword ptr </span><span style="color:#fa5c4b;">[</span><span style="color:#fdf4c1;">eax</span><span style="color:#fa5c4b;">]       </span><span style="color:#fe8019;">; </span><span style="color:#fdf4c1;">dereference the handle to
</span><span>                                                    </span><span style="color:#fe8019;">; </span><span style="color:#fdf4c1;">get the raw pointer
</span><span>    </span><span style="color:#fdf4c1;">02061079   mov         dword ptr </span><span style="color:#fa5c4b;">[</span><span style="color:#fdf4c1;">ecx</span><span style="color:#fa5c4b;">]</span><span style="color:#fdf4c1;">,100h      </span><span style="color:#fe8019;">; </span><span style="color:#fdf4c1;">Next 4 lines are
</span><span>    </span><span style="color:#fdf4c1;">0206107F   mov         dword ptr </span><span style="color:#fa5c4b;">[</span><span style="color:#fdf4c1;">ecx+4</span><span style="color:#fa5c4b;">]</span><span style="color:#fdf4c1;">,200h    </span><span style="color:#fe8019;">; </span><span style="color:#fdf4c1;">Singleton</span><span style="color:#b8bb26;">&#39;s inlined constructor
</span><span style="color:#b8bb26;">    02061086   mov         dword ptr [ecx+8],400h
</span><span style="color:#b8bb26;">    0206108D   mov         dword ptr [ecx+0Ch],0F84030h
</span></code></pre>
<p>可以看出会先分配内存，然后赋值给变量，这个时候变量指向的就是一个未初始化的对象，然后才会执行构造函数初始化这个对象。</p>
<p>在 Java5 之后，可以使用<code>volatile</code>原语，声明<code>helper</code>这个 field 为<code>volatile</code>，这样对于这个 field 的写操作与它之前的任何读写操作不会进行指令重排。对于读操作也不会与之后的任何读写操作指令重排。</p>
<pre data-lang="java" style="background-color:#282828;color:#fdf4c1aa;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#fa5c4b;">class </span><span style="color:#8ec07c;">Foo </span><span>{
</span><span>    </span><span style="color:#fa5c4b;">private volatile </span><span style="color:#8ec07c;">Helper </span><span>helper;
</span><span>    </span><span style="color:#fa5c4b;">public </span><span style="color:#8ec07c;">Helper getHelper</span><span>() {
</span><span>        </span><span style="color:#fa5c4b;">if </span><span>(helper </span><span style="color:#fe8019;">== </span><span style="color:#d3869b;">null</span><span>)
</span><span>        </span><span style="color:#fa5c4b;">synchronized</span><span>(</span><span style="color:#fdf4c1;">this</span><span>) {
</span><span>            </span><span style="color:#fa5c4b;">if </span><span>(helper </span><span style="color:#fe8019;">== </span><span style="color:#d3869b;">null</span><span>)
</span><span>            helper </span><span style="color:#fe8019;">= </span><span style="color:#fa5c4b;">new </span><span style="color:#8ec07c;">Helper</span><span>();
</span><span>        }
</span><span>        </span><span style="color:#fa5c4b;">return</span><span> helper;
</span><span>    }
</span><span>    </span><span style="font-style:italic;color:#928374;">// other functions and members...
</span><span>}
</span></code></pre>
<p>再回到我们的代码，我们这里是一个 map，在构造函数里已经初始化了，在加锁的这个 block 里只是生成一个 B 的对象，然后 put 进这个 map 里，这里不会有像<code>helper</code>那样未初始化的问题。另外就是在 map 上加了 volatile，并不会解决类似这样的问题，因为 volatile 是作用给了 map 本身，map 本身在这里的引用并没有变化，我们只是在更新它内部的状态。</p>
<p>参考</p>
<ul>
<li>http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html</li>
<li>http://gee.cs.oswego.edu/dl/cpj/jmm.html</li>
<li>http://www.cs.umd.edu/~pugh/java/memoryModel/</li>
<li>http://jeremymanson.blogspot.com/2008/05/double-checked-locking.html</li>
</ul>


<p class="tags-data">


<a href="/tags/synchronized">#synchronized</a>

<a href="/tags/java">#java</a>

<a href="/tags/multi-thread">#multi-thread</a>


</p>

	</main>
	<footer>
	    <span class="copyright">© Liang&#x27;s blog · Powered by <a target="_blank" href="https://getzola.org/">Zola</a></span>

	</footer>
    </body>
</html>
