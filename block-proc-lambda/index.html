<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta content="text/html; charset=UTF-8" http-equiv="content-type"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<meta name="robots" content="index, follow">















<title>block, proc, lambda</title>




<meta name="title" content="block, proc, lambda">


<meta name="description" content="ruby learning notes">

<meta property="og:type" content="website">
<meta property="og:url" content="https://blog.liangliu.me/block-proc-lambda/">

<meta property="og:site_name" content="Liang&#x27;s blog">


<meta property="og:title" content="block, proc, lambda">


<meta property="og:description" content="ruby learning notes">


<link rel="canonical" href="https://blog.liangliu.me/block-proc-lambda/">




<link rel="alternate" type="application/atom+xml" title="RSS" href="https://blog.liangliu.me/rss.xml"> 




<link rel="stylesheet" type="text/css" href="https://blog.liangliu.me/main.css">



    </head>
    <body>
	<header>
	    
                <a class="title" href="https:&#x2F;&#x2F;blog.liangliu.me">
                    <h1>Liang&#x27;s blog</h1>
                </a>
                <nav>
                    <p>
                    <a href="https:&#x2F;&#x2F;blog.liangliu.me">Home</a>
                    <a href="/about">Me</a>
                    <a href="/rss.xml">Rss</a>
                    </p>
                </nav>
	    
	</header>
	<main>
	    
<h1 class="page-title">block, proc, lambda</h1>
<p>
    <span>2013-10-27</span>
</p>

<h2 id="block">block</h2>
<p>block其实就是一些可以被执行的代码段，block的语法有2中形式，一种是do...end形式，一种是简写的{}形式，例如：</p>
<pre data-lang="ruby" style="background-color:#282828;color:#fdf4c1aa;" class="language-ruby "><code class="language-ruby" data-lang="ruby"><span>array1 </span><span style="color:#fe8019;">= </span><span>[</span><span style="color:#d3869b;">1</span><span>,</span><span style="color:#d3869b;">2</span><span>,</span><span style="color:#d3869b;">3</span><span>]
</span><span>array1.each </span><span style="color:#fa5c4b;">do </span><span>|</span><span style="color:#fdf4c1;">n</span><span>|
</span><span>    </span><span style="color:#fabd2f;">puts</span><span> n
</span><span style="color:#fa5c4b;">end
</span><span>array1.each { |</span><span style="color:#fdf4c1;">n</span><span>| </span><span style="color:#fabd2f;">puts</span><span> n }
</span></code></pre>
<p>block 一般跟times或者each，collect等方法一起使用，可以对某一个hash或者array中的元素进行操作。
用yield方法可以让函数接受一个block，例如：</p>
<pre data-lang="ruby" style="background-color:#282828;color:#fdf4c1aa;" class="language-ruby "><code class="language-ruby" data-lang="ruby"><span style="color:#fa5c4b;">def </span><span style="color:#8ec07c;">block_test
</span><span>  </span><span style="color:#fabd2f;">puts </span><span style="color:#b8bb26;">&quot;we are in the method!&quot;
</span><span>  </span><span style="color:#fa5c4b;">yield
</span><span>  </span><span style="color:#fabd2f;">puts </span><span style="color:#b8bb26;">&quot;we are back in the method!&quot;
</span><span style="color:#fa5c4b;">end
</span><span>block_test { </span><span style="color:#fabd2f;">puts </span><span style="color:#b8bb26;">&quot;we are in the block!&quot; </span><span>}
</span></code></pre>
<p>这样当函数执行到yield语句时候，就会调用传入的block。同时yield还可以处理传入的参数</p>
<pre data-lang="ruby" style="background-color:#282828;color:#fdf4c1aa;" class="language-ruby "><code class="language-ruby" data-lang="ruby"><span style="color:#fa5c4b;">def </span><span style="color:#8ec07c;">block_test</span><span>(</span><span style="color:#fdf4c1;">name</span><span>)
</span><span>  </span><span style="color:#fabd2f;">puts </span><span style="color:#b8bb26;">&quot;we are in the method!&quot;
</span><span>  </span><span style="color:#fa5c4b;">yield </span><span style="color:#fabd2f;">name
</span><span>  </span><span style="color:#fabd2f;">puts </span><span style="color:#b8bb26;">&quot;we are back in the method!&quot;
</span><span style="color:#fa5c4b;">end
</span><span>block_test(</span><span style="color:#b8bb26;">&quot;block&quot;</span><span>) { |</span><span style="color:#fdf4c1;">name</span><span>| </span><span style="color:#fabd2f;">puts </span><span style="color:#b8bb26;">&quot;we are in the </span><span>#{</span><span style="color:#fabd2f;">name</span><span>}</span><span style="color:#b8bb26;">!&quot; </span><span>}
</span></code></pre>
<h2 id="proc">proc</h2>
<p>在ruby中“任何都是对象”，但是其实对于blok来讲，它并不是对象，这是ruby中的一个例外，block不能保存到变量中，没有一个真正的对象使用起来那么方便，因此我们需要...proc, 它可以看做是保存成变量的block，这样我们可以给这个block起个名字，并可以重复调用它。</p>
<pre data-lang="ruby" style="background-color:#282828;color:#fdf4c1aa;" class="language-ruby "><code class="language-ruby" data-lang="ruby"><span>multiply_of_3 </span><span style="color:#fe8019;">= </span><span style="color:#8ec07c;">Proc</span><span>.</span><span style="color:#fa5c4b;">new do </span><span>|</span><span style="color:#fdf4c1;">n</span><span>|
</span><span>  n</span><span style="color:#fe8019;">%</span><span style="color:#d3869b;">3</span><span style="color:#fe8019;">==</span><span style="color:#d3869b;">0
</span><span style="color:#fa5c4b;">end
</span><span>(</span><span style="color:#d3869b;">1</span><span style="color:#fe8019;">..</span><span style="color:#d3869b;">100</span><span>).</span><span style="color:#fabd2f;">select</span><span>(</span><span style="color:#fe8019;">&amp;</span><span>multiply_of_3)
</span></code></pre>
<p>为什么要用proc呢，这里有2点需要理解的</p>
<ol>
<li>Procs是一个完全的对象，它具有所有对象的属性。</li>
<li>Procs在创建之后，可以在其他地方被重复调用，而block显然是不行的。</li>
</ol>
<p>我们可以直接使用Ruby的<code>.call</code>方法来调用一个Proc</p>
<pre data-lang="ruby" style="background-color:#282828;color:#fdf4c1aa;" class="language-ruby "><code class="language-ruby" data-lang="ruby"><span style="color:#fabd2f;">test </span><span style="color:#fe8019;">= </span><span style="color:#8ec07c;">Proc</span><span>.</span><span style="color:#fa5c4b;">new </span><span>{ </span><span style="color:#fe8019;">... </span><span>}
</span><span style="color:#fabd2f;">test</span><span>.call
</span></code></pre>
<h2 id="lambda">Lambda</h2>
<p>与proc一样，lambda也是对象，从一些语法和行为上来看，lambda跟proc在很多地方都是相同的。让我们来看一个lambda的例子吧</p>
<pre data-lang="ruby" style="background-color:#282828;color:#fdf4c1aa;" class="language-ruby "><code class="language-ruby" data-lang="ruby"><span style="color:#fabd2f;">lambda </span><span>{ </span><span style="color:#fabd2f;">puts </span><span style="color:#b8bb26;">&quot;hello&quot; </span><span>}
</span></code></pre>
<p>与下面这个proc是相同的</p>
<pre data-lang="ruby" style="background-color:#282828;color:#fdf4c1aa;" class="language-ruby "><code class="language-ruby" data-lang="ruby"><span style="color:#8ec07c;">Proc</span><span>.</span><span style="color:#fa5c4b;">new </span><span>{ </span><span style="color:#fabd2f;">puts </span><span style="color:#b8bb26;">&quot;hello&quot; </span><span>}
</span></code></pre>
<p>我们可以把一个lambda作为一个参数传递给一个函数</p>
<pre data-lang="ruby" style="background-color:#282828;color:#fdf4c1aa;" class="language-ruby "><code class="language-ruby" data-lang="ruby"><span style="color:#fa5c4b;">def </span><span style="color:#8ec07c;">test_lambda</span><span>(</span><span style="color:#fdf4c1;">p_lambda</span><span>)
</span><span>  </span><span style="color:#fabd2f;">puts </span><span style="color:#b8bb26;">&quot;I am the lambda test method.&quot;
</span><span>  p_lambda.call
</span><span style="color:#fa5c4b;">end
</span><span>test_lambda(</span><span style="color:#fabd2f;">lambda </span><span>{ </span><span style="color:#fabd2f;">puts </span><span style="color:#b8bb26;">&quot;I am the real lambda!&quot; </span><span>})
</span></code></pre>
<p>从以上例子可以看出来，可以通过以下方式来定义一个lambda
<code>lambda { block }</code></p>
<pre data-lang="ruby" style="background-color:#282828;color:#fdf4c1aa;" class="language-ruby "><code class="language-ruby" data-lang="ruby"><span>strings </span><span style="color:#fe8019;">= </span><span>[</span><span style="color:#b8bb26;">&quot;Germany&quot;</span><span>,</span><span style="color:#b8bb26;">&quot;Netherland&quot;</span><span>,</span><span style="color:#b8bb26;">&quot;England&quot;</span><span>,</span><span style="color:#b8bb26;">&quot;France&quot;</span><span>]
</span><span>symbolize </span><span style="color:#fe8019;">= </span><span style="color:#fabd2f;">lambda </span><span>{ |</span><span style="color:#fdf4c1;">n</span><span>| n.</span><span style="color:#fabd2f;">to_sym </span><span>}
</span><span>symbol </span><span style="color:#fe8019;">=</span><span> strings.collect(</span><span style="color:#fe8019;">&amp;</span><span>symbolize)
</span></code></pre>
<p>lambda和proc的不同点：
lambda会检查传入的参数数量，如果你传入了错误的参数数量，lambda会抛出一个异常，而proc不会检查，但是只会置为nil。
lambda在返回后会把控制权交给调用函数，而proc在返回后不会把控制权交给调用函数。</p>
<p>下面这个proc可以执行一下看下输出：</p>
<pre data-lang="ruby" style="background-color:#282828;color:#fdf4c1aa;" class="language-ruby "><code class="language-ruby" data-lang="ruby"><span style="color:#fa5c4b;">def </span><span style="color:#8ec07c;">batman_ironman_proc
</span><span>  victor </span><span style="color:#fe8019;">= </span><span style="color:#8ec07c;">Proc</span><span>.</span><span style="color:#fa5c4b;">new </span><span>{ </span><span style="color:#fa5c4b;">return </span><span style="color:#b8bb26;">&quot;Batman will win!&quot; </span><span>}
</span><span>  victor.call
</span><span>  </span><span style="color:#b8bb26;">&quot;Iron man will win!&quot;
</span><span style="color:#fa5c4b;">end
</span><span style="color:#fabd2f;">puts</span><span> batman_ironman_proc
</span></code></pre>
<p>我们可以看到结果，在Proc调用之后就结束了</p>
<pre data-lang="ruby" style="background-color:#282828;color:#fdf4c1aa;" class="language-ruby "><code class="language-ruby" data-lang="ruby"><span style="color:#fdf4c1;">Batman</span><span> will win!
</span></code></pre>
<p>再来看一个lambda的例子</p>
<pre data-lang="ruby" style="background-color:#282828;color:#fdf4c1aa;" class="language-ruby "><code class="language-ruby" data-lang="ruby"><span style="color:#fa5c4b;">def </span><span style="color:#8ec07c;">batman_ironman_lambda
</span><span>  victor </span><span style="color:#fe8019;">= </span><span style="color:#fabd2f;">lambda </span><span>{ </span><span style="color:#fa5c4b;">return </span><span style="color:#b8bb26;">&quot;Batman will win!&quot;
</span><span>  victor.call
</span><span>  </span><span style="color:#b8bb26;">&quot;Iron man will win!&quot;
</span><span style="color:#fa5c4b;">end
</span></code></pre>
<p>我们可以看到结果，在lambda调用之后回到了原来的函数中</p>
<pre data-lang="ruby" style="background-color:#282828;color:#fdf4c1aa;" class="language-ruby "><code class="language-ruby" data-lang="ruby"><span style="color:#fdf4c1;">Iron</span><span> man will win!
</span></code></pre>
<p>block,proc,lambda入门学习就先到这里，希望以后可以深入研究。</p>


<p class="tags-data">


<a href="/tags/ruby">#Ruby</a>


</p>

	</main>
	<footer>
	    <span class="copyright">© Liang&#x27;s blog · Powered by <a target="_blank" href="https://getzola.org/">Zola</a></span>

	</footer>
    </body>
</html>
